name: Release Management

on:
  push:
    branches: [main, master]
  pull_request:
    types: [closed]
    branches: [main, master]

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  release:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || (github.event.pull_request.merged == true)

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies for MCPClient
        working-directory: ./LeadLovers.Api.MCPClient
        run: npm ci

      - name: Run lint and build for MCPClient
        working-directory: ./LeadLovers.Api.MCPClient
        run: |
          npm run lint
          npm run build

      - name: Configure Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Check for changes since last release
        id: check_changes
        run: |
          # Get the latest tag
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

          if [ -z "$LATEST_TAG" ]; then
            echo "No previous tags found, proceeding with release"
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            # Check if there are conventional commits since the last tag
            COMMITS_SINCE_TAG=$(git log ${LATEST_TAG}..HEAD --oneline --grep="^feat" --grep="^fix" --grep="^perf" --grep="^refactor" --grep="^BREAKING CHANGE" --grep="^chore" --grep="^docs" --regexp-ignore-case)

            if [ -n "$COMMITS_SINCE_TAG" ]; then
              echo "Found releasable commits since $LATEST_TAG"
              echo "has_changes=true" >> $GITHUB_OUTPUT
            else
              echo "No releasable commits found since $LATEST_TAG"
              echo "has_changes=false" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Generate release version
        if: steps.check_changes.outputs.has_changes == 'true'
        id: version
        run: |
          # Determina o tipo de release baseado nos commits
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")

          # Remove 'v' prefix se existir
          CURRENT_VERSION=${LATEST_TAG#v}

          # Analisa commits para determinar bump type
          if git log ${LATEST_TAG}..HEAD --grep="BREAKING CHANGE" --regexp-ignore-case | grep -q .; then
            BUMP_TYPE="major"
          elif git log ${LATEST_TAG}..HEAD --grep="^feat" --regexp-ignore-case | grep -q .; then
            BUMP_TYPE="minor"
          else
            BUMP_TYPE="patch"
          fi

          # Calcula nova versão
          IFS='.' read -r major minor patch <<< "$CURRENT_VERSION"

          case $BUMP_TYPE in
            major)
              major=$((major + 1))
              minor=0
              patch=0
              ;;
            minor)
              minor=$((minor + 1))
              patch=0
              ;;
            patch)
              patch=$((patch + 1))
              ;;
          esac

          NEW_VERSION="${major}.${minor}.${patch}"
          echo "NEW_VERSION=v$NEW_VERSION" >> $GITHUB_ENV
          echo "new_version=v$NEW_VERSION" >> $GITHUB_OUTPUT

      - name: Update package versions
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          # Atualiza versão no MCPClient
          cd LeadLovers.Api.MCPClient
          npm version ${NEW_VERSION#v} --no-git-tag-version

          # Atualiza versão no MCPServer se existir package.json
          cd ../LeadLovers.Api.MCPServer
          if [ -f "package.json" ]; then
            npm version ${NEW_VERSION#v} --no-git-tag-version
          fi

          cd ..

      - name: Generate CHANGELOG
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

          # Cria ou atualiza CHANGELOG.md na raiz
          if [ ! -f "CHANGELOG.md" ]; then
            echo "# Changelog" > CHANGELOG.md
            echo "" >> CHANGELOG.md
            echo "All notable changes to this project will be documented in this file." >> CHANGELOG.md
            echo "" >> CHANGELOG.md
          fi

          # Prepara novo conteúdo
          echo "## [$NEW_VERSION] - $(date +%Y-%m-%d)" > new_changelog.md
          echo "" >> new_changelog.md

          # Adiciona mudanças por tipo
          echo "### Changes" >> new_changelog.md
          echo "" >> new_changelog.md

          if [ -n "$LATEST_TAG" ]; then
            # Features
            FEATURES=$(git log ${LATEST_TAG}..HEAD --grep="^feat" --pretty=format:"- %s (%h)" --regexp-ignore-case)
            if [ -n "$FEATURES" ]; then
              echo "#### Features" >> new_changelog.md
              echo "$FEATURES" >> new_changelog.md
              echo "" >> new_changelog.md
            fi

            # Fixes
            FIXES=$(git log ${LATEST_TAG}..HEAD --grep="^fix" --pretty=format:"- %s (%h)" --regexp-ignore-case)
            if [ -n "$FIXES" ]; then
              echo "#### Bug Fixes" >> new_changelog.md
              echo "$FIXES" >> new_changelog.md
              echo "" >> new_changelog.md
            fi

            # Other changes
            OTHER=$(git log ${LATEST_TAG}..HEAD --grep="^(chore|docs|style|refactor|perf|test)" --pretty=format:"- %s (%h)" --regexp-ignore-case)
            if [ -n "$OTHER" ]; then
              echo "#### Other Changes" >> new_changelog.md
              echo "$OTHER" >> new_changelog.md
              echo "" >> new_changelog.md
            fi
          else
            git log --pretty=format:"- %s (%h)" >> new_changelog.md
            echo "" >> new_changelog.md
          fi

          # Combina com CHANGELOG existente
          if [ -f "CHANGELOG.md" ]; then
            # Remove header do arquivo existente e adiciona novo conteúdo no topo
            tail -n +2 CHANGELOG.md > temp_changelog.md
            cat new_changelog.md >> CHANGELOG.md.new
            echo "" >> CHANGELOG.md.new
            cat temp_changelog.md >> CHANGELOG.md.new
            echo "# Changelog" > CHANGELOG.md
            echo "" >> CHANGELOG.md
            echo "All notable changes to this project will be documented in this file." >> CHANGELOG.md
            echo "" >> CHANGELOG.md
            cat CHANGELOG.md.new >> CHANGELOG.md
            rm CHANGELOG.md.new temp_changelog.md new_changelog.md
          fi

      - name: Commit changes
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          git add -A
          git commit -m "chore(release): $NEW_VERSION [skip ci]" || echo "No changes to commit"

      - name: Create and push tag
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          git tag -a $NEW_VERSION -m "Release $NEW_VERSION"
          git push origin HEAD
          git push origin $NEW_VERSION

      - name: Create GitHub Release
        if: steps.check_changes.outputs.has_changes == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          LATEST_TAG=$(git describe --tags --abbrev=0 --exclude=$NEW_VERSION 2>/dev/null || echo "")

          # Gera release notes dos commits
          if [ -n "$LATEST_TAG" ]; then
            git log ${LATEST_TAG}..$NEW_VERSION --pretty=format:"- %s" > release_notes.md
          else
            git log $NEW_VERSION --pretty=format:"- %s" > release_notes.md
          fi

          # Cria release no GitHub
          gh release create "$NEW_VERSION" \
            --title "Release $NEW_VERSION" \
            --notes-file release_notes.md